#noargs: ;
#onearg: 1234;
#hello: "Test!", 360*32, 240, some_var;

# declare variable of struct
# var test: struct SomeStruct;
# instead of var struct test: SomeStruct;

var test: int;
test = 4*2;

var c:int = 32 * 45;

# Would store the name print, and the number of arguments
# the bytecode generated should look something like
# CALL_NATIVE, name, nargs
# The actual fuction might look like:
# 
# uint32_t print_int(VirtualMachine *vm) {
# 	int32_t val = vm->stack[vm->sp--];
# 	printf("%d", val);
# 	return 0;
# }
# 
# The decleration
#
# cfunction print_int Integer i;
# cfunction println;
# cfunction native_add Integer a, Integer b;

function add int a, int b:
	var local: int = 1024*256;
	
	# Does not works since the bytecode expression writer
	# doesnt yet support variables
	return local;
endfunction

add: 11, 14;

# Calling this twice doesn't work. Probably has something to do with
# the stack
# Guessing its storing int the wrong location
#add: 11, 14;

var k: int = 12*666/2;

return 4 - 5;